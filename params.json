{
  "name": "Report",
  "tagline": "",
  "body": "# Final report\r\n\r\n[Previous logs](http://fcostantini.github.io/QuickFuzz/)\r\n\r\n## Motivation\r\n\r\nQuickFuzz can generate random code from various programming languages. Obviously, most of the time this code won't be syntactically or semantically valid. One of the things random code can't account for is variable coherence, i.e., using variables that are already defined.  \r\nMy project was about partially solving this problem, and automating the solution.  \r\n\r\n## Main work\r\n\r\nWe define a class (Fixable) that will take some language construction and will fix it in a way that adds (some) variable coherence.\r\n\r\n    data StV a = StV {vars :: [a]} deriving Show  \r\n\r\n    type VState a b = StateT (StV a) Gen b  \r\n\r\n    class Fixable a b where  \r\n      fix :: b -> VState a b  \r\n\r\nThe state is simply a list of variable identifiers, and we use a monad transformer to wrap the state around Gen. Basically we will be handling the state transformer, and at the end of the fix process, we must evaluate the state.  \r\n\r\nWe derive instances for this class using Template Haskell. The process for this is simple: we need to specify the type representing identifiers (could be simply String or a wrapper type), a list of constructors which will be variables \"calls\" (something like Var with an identifier), another list of constructors representing assignments (like a direct assignment or a for) and finally the type for which we want to derive the instance, lets call it T.  \r\n\r\nWhen we have all this, we can extract some information from these types to form the skeleton of our instance (like class restrictions on the type parameters). Then, the interesting bit is building the body of fix. To do this, we start travelling through the different constructors of T, and consider 3 different situations (say C is the current constructor of T being analyzed):  \r\n\r\n- if C is one of the constructors representing variables, we must make sure its identifier exists in the current state. If this is not the case, we have 2 situations: the state is empty, in which case we change the variable expression for a different one (it could be a constant, or simply an arbitrary expression), or we have some ids in the state, and then we take one of them randomly to replace the current one.  \r\n- if C is an assignment constructor, we must apply fix to the expression(s) that will be assigned, and then we add the assignment id to the state (this has some flaws, more info below).  \r\n- if C is not in either of the lists, we just apply fix to its parameters.  \r\n\r\nWe also need to define some functions to make it work. These functions are somewhat difficult to derive automatically because sometimes the specified constructors are not so straightforward (actually pop and push are pretty easy):  \r\n\r\n- getVId: extracts the identifier from a Variable expression.  \r\n- getAId: extracts the identifier from an Assignment expression.\r\n- printST: prints the state (not really necessary, but useful for debugging).  \r\n- popId: deletes an identifier from the state.  \r\n- pushId: adds an identifier to the state.  \r\n- genCons: the expression to put in when the state is empty.  \r\n- genVar: generates a Variable expression using an identifier from the state.  \r\n\r\nUsing Megadeth, we can get the instance derivation for an entire AST using just one line, since Megadeth can resolve type dependencies and will produce the instance for every type.  \r\n\r\n    $(mkGranFix ''Ident ['Var] ['Assign, 'For] ''Module)  \r\n\r\n## Results\r\n\r\n## Problems\r\n\r\n## Conclusion",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}