{
  "name": "Report",
  "tagline": "",
  "body": "# Final report\r\n\r\n[Previous logs](http://fcostantini.github.io/QuickFuzz/)\r\n\r\n## Motivation\r\n\r\nQuickFuzz can generate random code from various programming languages. Obviously, most of the time this code won't be syntactically or semantically valid. One of the things random code can't account for is variable coherence, i.e., when we use a variable, it must be defined (or declared) before. We can see this with this Python example (generated with more probability on assignments for illustration):  \r\n\r\n```python\r\nhiy = vu  \r\njdu = ag  \r\nrpa = kk\r\nzcx = 2\r\nvp = f  \r\nnp = 2.1850528035871353  \r\nb = 1 >> 0  \r\nzau = a  \r\nmeg = -18.39505230244595 == p  \r\nize = le  \r\nno = -2  \r\n```\r\n\r\nMy project was about partially solving this problem, and automating the solution. Our target languages were Python, JavaScript, Lua and Bash, but (hopefully) it should be easy to apply to others.  \r\n\r\n## Main work\r\n\r\n### Summary\r\n\r\n- Definition of Fixable class  \r\n- Required information  \r\n- Automatic instance derivation\r\n- Functions needed\r\n\r\n### Description\r\n\r\nWe define a class (Fixable) that will take some language construction and will fix it in a way that adds (some) variable coherence.\r\n\r\n```haskell\r\ndata StV a = StV {vars :: [a]} deriving Show  \r\n\r\ntype VState a b = StateT (StV a) Gen b  \r\n\r\nclass Fixable a b where  \r\n  fix :: b -> VState a b  \r\n```\r\n\r\nThe state is simply a list of variable identifiers, and we use a monad transformer to wrap the state around Gen. Basically we will be handling the state transformer, and at the end of the fix process, we must evaluate the state.  \r\n\r\nWe derive instances for this class using Template Haskell. The process for this is simple: we need to specify the type representing identifiers (could be simply String or a wrapper type), a list of constructors which will be variables \"calls\" (something like Var with an identifier), another list of constructors representing assignments (like a direct assignment or a for) and finally the type for which we want to derive the instance, let's call it T.  \r\n\r\nWhen we have all this, we can extract some information from these types to form the skeleton of our instance (like class restrictions on the type parameters). Then, the interesting bit is building the body of the fix function. To do this, we start travelling through the different constructors of T, and consider 3 different situations (say C is the current constructor of T being analyzed):  \r\n\r\n- if C is one of the constructors representing variables, we must make sure its identifier exists in the current state. If this is not the case, we have 2 situations: the state is empty, in which case we change the variable expression for a different one (it could be a constant, or simply an arbitrary expression); or we have some ids in the state, and then we take one of them randomly to replace the current one.  \r\n- if C is an assignment constructor, we must apply fix to the expression(s) that will be assigned, and then we add the assignment id to the state (this has some flaws, more info below).  \r\n- if C is not in either of the lists, we just apply fix to its parameters.  \r\n\r\nWe also need to define some functions to make it work. These functions are somewhat difficult to derive automatically because sometimes the specified constructors are not so straightforward (actually pop and push are pretty easy):  \r\n\r\n- getVId: extracts the identifier from a Variable expression.  \r\n- getAId: extracts the identifier from an Assignment expression.\r\n- printST: prints the state (not really necessary, but useful for debugging).  \r\n- popId: deletes an identifier from the state.  \r\n- pushId: adds an identifier to the state.  \r\n- genCons: the expression to put in when the state is empty.  \r\n- genVar: generates a Variable expression using an identifier from the state.  \r\n\r\nUsing Megadeth, we can get the instance derivation for an entire AST using just one line, since Megadeth can resolve type dependencies and will produce the instance for every type.  \r\n\r\n```haskell\r\n$(devFixLang ''Ident ['Var] ['Assign, 'For] ''Module)\r\n```\r\n\r\nAfter this, we must apply the fix somewhere. Currently this is manually done inside the Arbitrary instance for the top level type in the AST, using evalStateT to get rid of the state:  \r\n\r\n```haskell\r\ninstance Arbitrary T where  \r\n    arbitrary = do a <- sized go  \r\n                   evalStateT (fix a) (initV :: StV Id)  \r\n                where go n = ...  \r\n```\r\n\r\nAs an example, the Python module with variable coherence can be found [here](https://github.com/CIFASIS/QuickFuzz/blob/master/src/Python.hs).  \r\n\r\n## Results\r\n\r\nWe can test this with our previous Python example. After applying the fix, we get the following:\r\n\r\n```python\r\nhiy = 3  \r\njdu = hiy  \r\nrpa = jdu  \r\nzcz = 2  \r\nvp = zcz  \r\nnp = 2.1850528035871353   \r\nb = 1 >> 0  \r\nzau = jdu  \r\nmeg = -18.39505230244595 == zcz  \r\nize = vp  \r\nno = -2  \r\n```\r\n\r\nWe can see that now we reuse previously defined variables in new assignments.  \r\n\r\n### Testing\r\n\r\nWe ran QuickFuzz over different implementations of Bash, Python, Lua and JavaScript. So far we have found (after deduplicating the bugs using backtrace):\r\n\r\n- A bug in the current version of Lua (there's a patch available).  \r\n- A case where Python compilation takes a very long time (sometimes forever) [1](http://bugs.python.org/issue27695).\r\n- Aprox. 20 bugs in bash (waiting for feedback).\r\n- Aprox. 10 bugs in Busybox's implementation of bash (ash) (waiting for feedback).\r\n\r\n## Limitations\r\n\r\n- We mentioned that the user has to define some auxiliary functions to make the derivation work. These functions are pretty easy to understand so it's (or should be) easy to do it, but it's somewhat annoying.  \r\n- When we have assignments, there are two different situations to keep in mind: you can use the new variable in the \"body\" of the assignments (e.g. a for) or you can't (e.g. a normal assignment). Currently there is no way to distinguish these 2 cases, and every case is treated like it's of the second class. This could be easily fixed by separating assignments into two lists (or providing more information), but we decided to leave it as it is for now.  \r\n- It takes some work to check and understand the target language's AST in order to correctly identify the information we need.  \r\n\r\n## Future work\r\n\r\n- As said in the previous section, it would be desirable to automatically get the necessary functions instead of asking for the user to provide them, at least if it's easy to produce them.  \r\n- Providing more information can lead to better results. An example could be adding function parameters to our state.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}